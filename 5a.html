<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Access 4 - Module 5a</title>
    <style>
        /* ========================================================================
        TECHNICAL REQUIREMENTS IMPLEMENTED:
        
        1. DATA INTEGRITY: All content from provided images preserved exactly, also all CSS design
        
        2. STICKY UI: Word Bank follows scrolling when needed with position: sticky
        
        3. SINGLE SOLVE: Individual 'Show' buttons per question with üëÅÔ∏è icon
        
        4. PEDAGOGICAL HINTS: Detailed English explanations via (i) button toggle
        
        5. SAFE-HIGHLIGHT: Keyword highlighting on error (green/red color coding)
           - Green (#27ae60) for correct answers
           - Red (#e74c3c) for incorrect answers
           - Background colors change to indicate status
        
        6. CLICK-TO-SELECT & DRAG-DROP: Dual input methods for Word Bank
           - Click on word bank items to select them
           - Drag and drop onto input fields
           - Visual feedback with color change (#ffeaa7 for selected)
        
        7. AUTO-WIDTH: Inputs resize based on content using oninput event
           - Base widths: letter-input=45px, preposition-input=80px, word-input=120px, grammar-input=150px
           - Dynamic adjustment: Math.max(el.value.length * 10 + 20, baseWidth)
        
        8. CASE-INSENSITIVE: Matching handles A/a equally via normalizeAnswer() function
           - Converts to lowercase, trims whitespace, removes punctuation
        
        9. WORD BANK MANAGEMENT: Auto-hide used items with frequency tracking
           - Counts occurrences of each word in inputs
           - Hides items when used count >= total available (handles x2 duplicates)
        
        10. LOCAL CONTROLS: Individual Task 'Show All' and 'Reset' buttons
            - Each exercise has its own control buttons
            - Prefix-based selection for targeted operations
        
        11. KEYBOARD: Enter to check all answers, Arrow keys for navigation
            - Event listener on document for keydown events
            - Enter key triggers checkAll() function
        
        12. ENHANCED HINTS: Detailed explanations for every question
            - Hidden divs that toggle on (i) button click
            - Each hint contains pedagogical explanation
        
        13. AUTOMATIC FORMAT DETECTION: Based on data structure
            - RULE 1: MATCHING EXERCISE - objects with 'v', 'letter', 'def', 'hint', 'ipa' properties
            - RULE 2: GAP-FILL WITH WORD BANK - objects with 'q', 'ans', 'hint', 'wordBankIndex' properties
            - RULE 3: PREPOSITION/VERB TENSES - objects with 'q', 'ans', 'hint' with multiple gaps
            - RULE 4: MULTIPLE CHOICE (TASK 5 TYPE 1) - objects with 'q', 'ans', 'hint', 'options' array property
            - RULE 5: ERROR CORRECTION (TASK 5 TYPE 2) - objects with 'words' array, 'errIdx', 'corr', 'hint' properties
        
        14. MULTI-FORMAT SUPPORT:
            - Vocabulary Matching (Task 1): 2-column grid with letter inputs and IPA pronunciation
            - Gap-fill with Word Bank (Task 2): Input fields with sticky word bank, drag & drop
            - Past Simple & Past Progressive (Task 3): Verb tense exercises with multiple gaps
            - Past Simple & Past Perfect (Task 4): Verb tense exercises with multiple gaps  
            - Phrasal Verbs (Task 5 Type 1): Multiple choice with 3 option buttons
            - Error Correction (Task 5 Type 2): Clickable phrases with correction input
        
        15. EXERCISE NUMBER HANDLING: Preserves existing numbering from content
            - If sentences already have numbers (like "1.", "2."), uses those numbers
            - Otherwise uses automatic numbering with exercise-number class
            - Number detection regex: /^\d+\.\s/
        
        16. DOCUMENTATION PRESERVATION: All technical requirement comments maintained
            - This section must remain intact in any derivative code
            - New requirements added as additional numbered points
            - Never modify or remove existing technical requirements
            - Always keep the complete history of all requirements
        
        17. IPA PRONUNCIATION FEATURE FOR MATCHING EXERCISES:
            - Each vocabulary item in matching exercises has IPA pronunciation data
            - Speaker button (üîä) added next to eye (üëÅÔ∏è) button
            - Clicking speaker button shows IPA pronunciation in a dedicated box
            - IPA data stored in 'ipa' property of vocabulary objects
            - Visual design: IPA box appears below each vocabulary item
        
        18. MULTIPLE CORRECT ANSWERS SUPPORT:
            - For exercises where multiple answers are possible,
              answers can be stored as arrays or pipe-separated strings
            - Validation logic checks if user answer matches any of the acceptable answers
            - Supports British/American spelling variations
            - CRITICAL FIX: For single-gap questions with pipe-separated answers,
              the entire pipe-separated string MUST be stored in input's data-ans attribute
        
        19. CONTEXT-AWARE VALIDATION:
            - Grammar structures: Alternative correct forms accepted based on pedagogical context
        
        20. CONSISTENT CASE HANDLING FOR WORD BANKS AND ANSWERS:
            - WORD BANK ITEMS: Always displayed in lowercase for visual consistency
            - ANSWER DISPLAY: Show answers with exact original capitalization from data
            - VALIDATION: Case-insensitive comparison during validation
            - USER INPUT: Preserves user's original capitalization input
        
        21. CASE HANDLING IMPLEMENTATION:
            - Word bank creation: Uses toLowerCase() for all displayed words
            - Answer display: Shows exact 'ans' property from data (preserves original case)
            - Validation: Uses normalizeAnswer() for case-insensitive comparison
            - User experience: No automatic case modification during user typing
        
        22. GAP DETECTION AND REPLACEMENT:
            - Any occurrence of "______" (any length of underscores) in question text is automatically
              replaced with an input field
            - Regex pattern: /_{2,}/g matches 2 or more consecutive underscores
            - This handles variations in gap length from different sources
            - Input fields are inserted exactly where the underscores appear
        
        23. MATCHING EXERCISE TWO-COLUMN LAYOUT WITH IPA:
            - Left column: Vocabulary items with input boxes for matching letters
            - Right column: Definitions in alphabetical order (A, B, C, D, etc.)
            - Each vocabulary item has three control buttons:
              1. üëÅÔ∏è Eye button: Shows the correct answer
              2. üîä Speaker button: Shows IPA pronunciation
              3. (i) Info button: Shows pedagogical hint
            - IPA pronunciation data comes from reliable dictionary sources
        
        24. IPA PRONUNCIATION IMPLEMENTATION:
            - Speaker button size matches eye button (28x28px)
            - IPA data stored in 'ipa' property of vocabulary objects
            - IPA display uses phonetic font and proper formatting
        
        25. IPA SINGLE ACTIVE DISPLAY SYSTEM:
            - Only ONE IPA pronunciation box can be visible at a time
            - Clicking a speaker button shows that word's IPA and hides any other visible IPA box
            - Clicking the same speaker button again toggles (hides) its IPA box
            - This prevents visual clutter and ensures clean interface
        
        26. DEFINITIONS COLUMN OPTIMIZATION:
            - Definitions column displays clean list without unnecessary headers
            - Alphabetical ordering (A, B, C, D) maintained for easy reference
            - Visual hierarchy maintained through consistent styling
        
        27. SCROLLABLE DEFINITIONS COLUMN FOR MATCHING EXERCISES:
            - Definitions column has independent vertical scrolling when content is too long
            - Fixed height with overflow-y: auto enables scrolling within the column
            - Scrollbar styling matches the design system with subtle appearance
        
        28. MULTI-GAP QUESTIONS WITH SEPARATE VALIDATION:
            - For questions with multiple gaps, each gap gets its own input field
            - Data structure supports multiple answers in one 'ans' field separated by |
            - Validation checks each input field against its corresponding answer
        
        29. TOGGLE FUNCTIONALITY FOR EYE AND INFO BUTTONS:
            - Eye button (üëÅÔ∏è) toggles answer display on second click
            - Info button (i) toggles hint display on second click
            - Both buttons restore original state when clicked again
        
        30. MULTIPLE CORRECT ANSWERS FIX FOR SINGLE-GAP QUESTIONS:
            - CRITICAL FIX: For single-gap questions with pipe-separated answers,
              the entire pipe-separated string must be stored in the input's data-ans attribute
            - FIXED: Input elements now receive the complete pipe-separated answer string
              from the data object's 'ans' property
        
        31. PAST TENSE FORMS EXERCISE:
            - Task 3 includes Past Simple & Past Progressive verb forms
            - Task 4 includes Past Simple & Past Perfect verb forms
            - Verb tense reference section explains usage rules
            - Input fields designed for verb conjugation
        
        32. PHRASAL VERBS MULTIPLE CHOICE EXERCISE:
            - Task 5 Type 1 focuses on phrasal verb selection
            - Multiple choice format with three options
            - Comprehensive phrasal verb explanations
        
        33. OPTION-SELECTION EXERCISE IF DETECTED:
            - NEW REQUIREMENT: Uses option selection instead of text input
            - Students choose from provided options for each question
            - Options are presented as clickable buttons
            - Visual feedback: Green for correct, Red for incorrect selection
            - Data structure includes 'options' array property
            - Eye button (üëÅÔ∏è) shows correct answer by highlighting the correct option
            - Hint button (i) provides pedagogical explanation
        
        34. ADAPTIVE INPUT WIDTH EXPANSION:
            - Input fields automatically expand to show complete text content
            - Uses character counting with dynamic width calculation
            - Minimum widths ensure usability for empty fields
            - Maximum widths prevent excessive expansion beyond container bounds
            - Special handling for long answers in verb tense and grammar inputs
        
        35. CLEAN OPTION-FORMATTING FOR PHRASAL VERB EXERCISES:
            - NEW REQUIREMENT: For option selection exercises, ensure clean sentence formatting
            - Options should NOT appear within the sentence text itself
            - Sentence should show only the context, with options displayed separately
            - This prevents duplication and maintains readability
            - Algorithm detects and removes duplicate option text from sentence
        
        36. TASK 5 SELECTIVE CHECK AND COMPLETE RESET:
            - NEW REQUIREMENT: Check All/Enter ONLY validates questions that have been selected
            - Unselected questions remain completely untouched (no color changes)
            - No automatic showing of correct answers for unselected questions
            - Reset button completely restores option buttons to original white state
            - All color classes are removed, not just check-related ones
        
        37. TASK 5 ANSWER REVEAL BEHAVIOR FIX:
            - NEW REQUIREMENT: Check All button does NOT automatically show correct answers for Task 5
            - Eye button (üëÅÔ∏è) is required to reveal correct answer for individual questions
            - Show All button still shows all correct answers when clicked
            - Check All only validates user selections without revealing unselected answers
            - This prevents "spoiling" the exercise while allowing targeted checking
        
        38. TASK 5 RESET FIX FOR STYLING PERSISTENCE:
            - NEW REQUIREMENT: Fix Task 5 reset to properly clear all styling and inline styles
            - Problem: After Check All, reset button didn't fully restore original colors
            - Solution: Use style.cssText = '' to clear all inline styles
            - Ensures complete visual reset to original white state
            - Also resets eye button active states
        
        39. TASK 3 & 4 EYE BUTTON FIX FOR MULTI-GAP QUESTIONS:
            - NEW REQUIREMENT: Fix eye button functionality for multi-gap questions (Task 3 & 4)
            - Problem: Eye button didn't work for questions with multiple input fields
            - Solution: Modify toggleSingleAns() to handle question prefixes
            - Implementation: Find all input fields with matching question prefix
            - Show/hide all gaps simultaneously for consistent user experience
        
        40. TASK 5 TYPE RECOGNITION AND HANDLING:
            - IMPORTANT: There are TWO distinct Task 5 formats across different modules:
              1. MULTIPLE CHOICE (Type 1): Data has 'options' array property (Module 5a)
              2. ERROR CORRECTION (Type 2): Data has 'words' array and 'errIdx' property (Module 4a)
            - Automatic detection based on data structure:
              * If data[0].options exists ‚Üí Multiple Choice (use renderPhrasalVerbs())
              * If data[0].words exists ‚Üí Error Correction (use renderErrorCorrection())
            - Each type has completely different UI and interaction patterns
        
        41. ERROR CORRECTION WITH SELECTABLE PHRASES (TASK 5 TYPE 2):
            - Displays sentences with logically grouped phrases
            - Each phrase is clickable to select the incorrect part
            - Selected phrase is visually highlighted with yellow background
            - Clicking a phrase auto-fills the correction input field
            - Data structure: {words: [], errIdx, corr, hint}
            - Show All button automatically selects the error phrase and shows correction
        
        42. MULTIPLE CHOICE WITH OPTION BUTTONS (TASK 5 TYPE 1):
            - Displays 3 option buttons per question
            - User selects one option per question
            - Check All only validates selected questions
            - Reset clears all inline styles completely
            - Data structure: {q, ans, options: [], hint}
        
        ======================================================================== */
        
        /* [CSS styles remain EXACTLY the same - no changes] */
        :root {
            --primary: #2980b9; 
            --primary-dark: #1c5982; 
            --success: #27ae60;
            --error: #e74c3c; 
            --warning: #f1c40f; 
            --bg: #f4f7f9;
            --text: #2c3e50; 
            --card: #ffffff;
            --selection: #3498db;
            --selection-bg: #ebf5fb;
        }
        
        body { 
            font-family: 'Times New Roman', serif; 
            font-size: 13pt; 
            background-color: var(--bg); 
            color: var(--text); 
            margin: 0; 
            padding: 20px 20px 100px 20px; 
            line-height: 1.6; 
        }
        
        .container { 
            max-width: 1000px; 
            margin: 0 auto; 
        }
        
        .sticky-bank { 
            position: sticky; 
            top: 15px; 
            z-index: 100;
            background-color: #fff; 
            padding: 15px; 
            border-radius: 10px; 
            margin-bottom: 25px; 
            border: 2px solid var(--primary); 
            display: flex; 
            flex-wrap: wrap; 
            gap: 10px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .word-item { 
            background: #eef2f7; 
            border: 1px solid var(--primary); 
            color: var(--primary-dark); 
            padding: 6px 12px; 
            border-radius: 5px; 
            cursor: grab; 
            user-select: none; 
            transition: 0.2s; 
            font-size: 0.9em; 
            font-weight: 500;
        }
        
        .word-item.used { 
            display: none; 
        }
        
        .word-item:hover { 
            background: var(--primary); 
            color: white; 
        }

        .exercise-card { 
            background: var(--card); 
            border-radius: 12px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); 
            padding: 25px; 
            margin-bottom: 30px; 
        }
        
        .exercise-title { 
            font-weight: bold; 
            font-size: 1.25em; 
            margin-bottom: 18px; 
            color: var(--primary-dark); 
            border-bottom: 2px solid #eee; 
            padding-bottom: 8px; 
        }
        
        .matching-grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 30px; 
            margin-top: 10px; 
        }
        
        .vocab-item { 
            margin-bottom: 12px; 
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }
        
        .vocab-text { 
            min-width: 150px; 
            font-weight: 500; 
        }
        
        .def-item { 
            margin-bottom: 12px; 
            padding: 4px 0; 
            border-bottom: 1px solid #f0f0f0; 
            min-height: 40px; 
            display: flex; 
            align-items: center; 
        }

        .question-row { 
            margin-bottom: 18px; 
            line-height: 2.2; 
            border-bottom: 1px solid #f9f9f9; 
            padding-bottom: 10px; 
            position: relative; 
        }
        
        input[type="text"] { 
            border: none; 
            border-bottom: 2px solid #bdc3c7; 
            background: #fafafa; 
            padding: 2px 8px; 
            font-size: 1em; 
            transition: 0.2s; 
            outline: none;
            min-width: 60px; 
            border-radius: 4px 4px 0 0; 
            text-align: center; 
            font-family: 'Times New Roman';
            box-sizing: border-box;
        }
        
        input.letter-input { 
            width: 45px; 
            min-width: 45px; 
            max-width: 80px;
            text-transform: uppercase; 
            font-weight: bold; 
            color: var(--primary-dark); 
        }
        
        input.word-input { 
            min-width: 120px; 
            max-width: 400px;
            text-align: left; 
        }
        
        input.grammar-input { 
            min-width: 150px; 
            max-width: 500px;
            text-align: left; 
        }
        
        input.correct { 
            border-bottom-color: var(--success) !important; 
            background-color: #e8f8f5 !important; 
            color: #1e8449 !important; 
        }
        
        input.incorrect-marked { 
            border-bottom-color: var(--error) !important; 
            background-color: #fdedec !important; 
        }

        .row-btns { 
            display: inline-flex; 
            gap: 5px; 
            vertical-align: middle; 
            margin-left: 10px; 
        }
        
        .btn-small { 
            background: #eee; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            width: 28px; 
            height: 28px; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 14px; 
            transition: 0.2s;
        }
        
        .btn-small:hover {
            background: #ddd;
        }
        
        .btn-small.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .speaker-btn {
            background: #3498db;
            color: white;
            border: none;
        }
        
        .speaker-btn:hover {
            background: #2980b9;
        }
        
        .speaker-btn.active {
            background: #1c5982;
        }
        
        .info-btn { 
            background: #95a5a6; 
            color: white; 
            border: none; 
            border-radius: 50%; 
            width: 20px; 
            height: 20px; 
            font-size: 11px; 
            cursor: pointer; 
            display: inline-flex; 
            align-items: center; 
            justify-content: center; 
            transition: 0.2s;
        }
        
        .info-btn:hover {
            background: #7f8c8d;
        }
        
        .info-btn.active {
            background: #5d6d6e;
        }
        
        .hint-box { 
            display: none; 
            margin-top: 8px; 
            padding: 10px; 
            background-color: #fef9e7; 
            border-left: 4px solid var(--warning); 
            color: #7d6608; 
            border-radius: 4px; 
            font-size: 0.85em; 
        }
        
        .ipa-box {
            display: none;
            margin-top: 8px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #3498db;
            color: #2c3e50;
            border-radius: 4px;
            font-size: 0.9em;
            font-family: 'Times New Roman', serif;
        }
        
        .ipa-label {
            font-weight: bold;
            color: #3498db;
            margin-right: 5px;
        }
        
        .ipa-text {
            font-family: 'Times New Roman', serif;
            font-style: italic;
        }

        .controls-row { 
            display: flex; 
            justify-content: flex-end; 
            gap: 10px; 
            margin-top: 15px; 
        }
        
        .btn { 
            padding: 8px 20px; 
            border-radius: 6px; 
            cursor: pointer; 
            border: none; 
            font-weight: bold; 
            transition: 0.3s; 
        }
        
        .btn-reset { 
            background: #95a5a6; 
            color: white; 
        }
        
        .btn-show-all { 
            background: var(--primary); 
            color: white; 
        }
        
        .check-all-btn { 
            position: fixed; 
            right: 30px; 
            bottom: 30px; 
            background-color: var(--success); 
            color: white; 
            padding: 15px 30px; 
            border-radius: 50px; 
            cursor: pointer; 
            z-index: 1000; 
            font-weight: bold; 
            border: none; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2); 
        }
        
        /* Grammar reference section */
        .grammar-reference {
            background-color: #f8f9fa;
            border-left: 4px solid var(--primary);
            padding: 15px;
            margin-top: 25px;
            border-radius: 0 8px 8px 0;
            font-size: 0.9em;
        }
        
        .grammar-reference h3 {
            margin-top: 0;
            color: var(--primary-dark);
            font-size: 1.1em;
        }
        
        .grammar-reference table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        .grammar-reference th {
            background-color: #e3f2fd;
            padding: 10px;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        .grammar-reference td {
            padding: 10px;
            border: 1px solid #ddd;
        }
        
        .grammar-reference ul {
            padding-left: 20px;
        }
        
        .grammar-reference li {
            margin-bottom: 8px;
        }
        
        .reference-note {
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.85em;
            margin-top: 10px;
            text-align: center;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        
        /* Exercise numbering */
        .instructions {
            color: #7f8c8d;
            font-size: 0.95em;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        /* Number handling - preserves existing numbers */
        .existing-number {
            font-weight: bold;
            color: var(--primary);
            margin-right: 8px;
        }
        
        /* Definitions column styling - UPDATED WITH SCROLL */
        .definitions-column {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            height: 500px; /* Fixed height for scrollable area */
            overflow-y: auto; /* Enable vertical scrolling */
        }
        
        /* Custom scrollbar styling */
        .definitions-column::-webkit-scrollbar {
            width = 8px;
        }
        
        .definitions-column::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .definitions-column::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }
        
        .definitions-column::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        
        .definition-item {
            margin-bottom: 12px;
            padding: 8px;
            border-bottom: 1px solid #eee;
            background-color: white;
            border-radius: 4px;
            min-height: 40px; /* Ensure consistent height */
        }
        
        .definition-letter {
            font-weight: bold;
            color: var(--primary);
            margin-right: 10px;
            min-width: 20px;
            display: inline-block;
        }
        
        .definition-text {
            display: inline;
        }
        
        /* Option selection styling for Task 5 - UPDATED FOR 3 OPTIONS */
        .option-container {
            display: inline-flex;
            gap: 10px;
            margin-left: 10px;
            margin-right: 10px;
            flex-wrap: wrap;
        }
        
        .option-btn {
            background: #eef2f7; /* Original white-ish background */
            border: 2px solid #bdc3c7;
            border-radius: 6px;
            padding: 6px 15px;
            cursor: pointer;
            font-weight: 500;
            transition: 0.2s;
            min-width: 80px;
            text-align: center;
            font-size: 0.9em;
        }
        
        .option-btn:hover {
            background: #dfe6f0;
            border-color: #95a5a6;
        }
        
        .option-btn.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .option-btn.correct-option {
            background: #27ae60;
            color: white;
            border-color: #219653;
        }
        
        .option-btn.incorrect-option {
            background: #e74c3c;
            color: white;
            border-color: #c0392b;
        }
        
        /* Long text handling for inputs */
        .long-answer {
            font-size: 0.95em;
            letter-spacing: 0.3px;
        }
        
        /* Verb form specific styling */
        .verb-input {
            min-width: 80px;
            max-width: 200px;
            text-align: center;
        }
        
        /* Bold formatting for options in question text */
        .bold-option {
            font-weight: bold;
            color: var(--primary-dark);
        }
    </style>
</head>
<body>

<div class="container">
    <h1 style="text-align: center; color: var(--primary-dark); margin-bottom: 30px;">Access 4 - Module 5a</h1>
    
    <!-- Grammar Reference Section -->
    <div class="exercise-card">
        <div class="exercise-title">Grammar Reference & Study Notes</div>
        <div class="grammar-reference">
            <h3>Past Simple Tense:</h3>
            <p><strong>Form:</strong> Subject + verb in past form (regular: +ed; irregular: special form)</p>
            <p><strong>Use:</strong> Completed actions in the past at a specific time.</p>
            <p><strong>Example:</strong> I <strong>watched</strong> TV last night. She <strong>went</strong> to Paris in 2019.</p>
            
            <h3>Past Progressive Tense:</h3>
            <p><strong>Form:</strong> Subject + was/were + verb-ing</p>
            <p><strong>Use:</strong> Actions in progress at a specific time in the past; interrupted actions.</p>
            <p><strong>Example:</strong> I <strong>was watching</strong> TV when you called. They <strong>were studying</strong> at 8 PM yesterday.</p>
            
            <h3>Past Perfect Tense:</h3>
            <p><strong>Form:</strong> Subject + had + past participle</p>
            <p><strong>Use:</strong> Actions completed before another action or time in the past.</p>
            <p><strong>Example:</strong> She <strong>had finished</strong> her homework before I arrived.</p>
            
            <h3>Phrasal Verbs:</h3>
            <table>
                <tr>
                    <th>Phrasal Verb</th>
                    <th>Meaning</th>
                    <th>Example</th>
                </tr>
                <tr>
                    <td><strong>take over</strong></td>
                    <td>To gain control or responsibility</td>
                    <td>Steve decided to <strong>take over</strong> the family wildlife park.</td>
                </tr>
                <tr>
                    <td><strong>take off</strong></td>
                    <td>To become successful; to leave the ground (plane)</td>
                    <td>His career really <strong>took off</strong> after his first documentary.</td>
                </tr>
                <tr>
                    <td><strong>take up</strong></td>
                    <td>To start a new hobby or activity</td>
                    <td>She decided to <strong>take up</strong> photography as a hobby.</td>
                </tr>
                <tr>
                    <td><strong>take after</strong></td>
                    <td>To resemble a family member</td>
                    <td>Steve <strong>takes after</strong> his father in many ways.</td>
                </tr>
                <tr>
                    <td><strong>take on</strong></td>
                    <td>To accept responsibility or challenge</td>
                    <td>He decided to <strong>take on</strong> the new project.</td>
                </tr>
            </table>
            
            <p class="reference-note">Grammar references based on Cambridge English Grammar in Use and Oxford English Grammar Course.</p>
        </div>
    </div>

    <!-- TASK 1: Vocabulary Matching -->
    <div class="exercise-card" id="card-t1">
        <div class="exercise-title">Task 1: Vocabulary Matching ‚Äì Match the word to its meaning</div>
        <div class="instructions">Match the vocabulary word on the left with its definition on the right by entering the correct letter (A-K) in the box.</div>
        
        <div class="matching-grid">
            <div id="vocab-t1"></div>
            <div class="definitions-column">
                <div id="def-t1"></div>
            </div>
        </div>
        <div class="controls-row">
            <button class="btn btn-show-all" onclick="showAnswers('t1')">Show All</button>
            <button class="btn btn-reset" onclick="resetSection('t1')">Reset</button>
        </div>
    </div>

    <!-- TASK 2: Gap-fill with Word Bank -->
    <div class="exercise-card" id="card-t2">
        <div class="exercise-title">Task 2: Filling in the gaps ‚Äì Complete the sentences</div>
        <div class="instructions">Complete each sentence by dragging and dropping the correct word from the word bank or typing it in the gap.</div>
        
        <!-- Sticky Word Bank -->
        <div class="sticky-bank" id="bank-t2"></div>
        
        <!-- Questions -->
        <div id="questions-t2"></div>
        <div class="controls-row">
            <button class="btn btn-show-all" onclick="showAnswers('t2')">Show All</button>
            <button class="btn btn-reset" onclick="resetSection('t2')">Reset</button>
        </div>
    </div>

    <!-- TASK 3: Past Simple & Past Progressive -->
    <div class="exercise-card" id="card-t3">
        <div class="exercise-title">Task 3: Past Simple & Past Progressive</div>
        <div class="instructions">Complete each sentence with the correct form of the verb in brackets. Use Past Simple or Past Progressive as appropriate.</div>
        <div id="questions-t3"></div>
        <div class="controls-row">
            <button class="btn btn-show-all" onclick="showAnswers('t3')">Show All</button>
            <button class="btn btn-reset" onclick="resetSection('t3')">Reset</button>
        </div>
    </div>

    <!-- TASK 4: Past Simple & Past Perfect -->
    <div class="exercise-card" id="card-t4">
        <div class="exercise-title">Task 4: Past Simple & Past Perfect</div>
        <div class="instructions">Complete each sentence with the correct form of the verb in brackets. Use Past Simple or Past Perfect as appropriate.</div>
        <div id="questions-t4"></div>
        <div class="controls-row">
            <button class="btn btn-show-all" onclick="showAnswers('t4')">Show All</button>
            <button class="btn btn-reset" onclick="resetSection('t4')">Reset</button>
        </div>
    </div>

    <!-- TASK 5: Phrasal Verbs ‚Äì Choose the correct option -->
    <div class="exercise-card" id="card-t5">
        <div class="exercise-title">Task 5: Phrasal Verbs ‚Äì Choose the correct option</div>
        <div class="instructions">Choose the correct phrasal verb in each sentence.</div>
        <div id="questions-t5"></div>
        <div class="controls-row">
            <button class="btn btn-show-all" onclick="showAnswers('t5')">Show All</button>
            <button class="btn btn-reset" onclick="resetSection('t5')">Reset</button>
        </div>
    </div>
</div>

<button class="check-all-btn" onclick="checkAll()">CHECK ALL ANSWERS (ENTER)</button>

<script>
/* --- DATA --- */

// Task 1: Vocabulary Matching ‚Äì Match the word to its meaning
const t1_data = [
    { v: "1. python", letter: "B", def: "a large snake that kills animals by squeezing them", hint: "A python is a type of large constrictor snake. It's non-venomous and kills its prey by coiling around it and squeezing.", ipa: "/Ààpa…™Œ∏…ôn/" },
    { v: "2. well-known", letter: "G", def: "famous or known by many people", hint: "Well-known means widely recognized or famous. Steve Irwin was a well-known wildlife expert.", ipa: "/Àåwel Ààno än/" },
    { v: "3. reptiles", letter: "H", def: "animals with cold blood and dry skin, such as snakes and lizards", hint: "Reptiles are a class of animals that include snakes, lizards, turtles, and crocodiles. They have scales and are cold-blooded.", ipa: "/Ààrepta…™lz/" },
    { v: "4. mammals", letter: "C", def: "animals that are warm-blooded and usually feed milk to their young", hint: "Mammals are warm-blooded vertebrates that have hair or fur and produce milk for their young. Examples: dogs, cats, humans, dolphins.", ipa: "/Ààm√¶m…ôlz/" },
    { v: "5. take over", letter: "J", def: "to gain control or responsibility for something", hint: "Take over means to assume control or responsibility. Example: 'Steve decided to take over the family wildlife park.'", ipa: "/te…™k Àào äv…ôr/" },
    { v: "6. honeymoon", letter: "K", def: "a holiday taken by a couple immediately after getting married", hint: "A honeymoon is a vacation taken by newlyweds to celebrate their marriage. It often follows the wedding ceremony.", ipa: "/Ààh ån…™muÀên/" },
    { v: "7. passion", letter: "I", def: "strong enthusiasm or deep interest in something", hint: "Passion is a strong feeling of enthusiasm or excitement for something. Steve Irwin had a passion for wildlife conservation.", ipa: "/Ààp√¶ É…ôn/" },
    { v: "8. instill", letter: "E", def: "to gradually put an idea, value, or feeling into someone's mind", hint: "To instill means to gradually but firmly establish an idea or attitude in someone. Example: 'His parents helped instill a deep respect for animals in him.'", ipa: "/…™nÀàst…™l/" },
    { v: "9. exceptional", letter: "D", def: "extremely good or unusual compared to others", hint: "Exceptional means unusually good or outstanding. It describes something that stands out from the ordinary.", ipa: "/…™kÀàsep É…ôn…ôl/" },
    { v: "10. stingray", letter: "F", def: "a sea creature with a flat body and a long tail that can cause injury", hint: "A stingray is a flat marine fish with a venomous stinger on its tail. Steve Irwin died from a stingray injury.", ipa: "/Ààst…™≈ãre…™/" },
    { v: "11. amphibians", letter: "A", def: "animals that are born from eggs and live both on land and in water", hint: "Amphibians are animals that can live both in water and on land. Examples: frogs, toads, salamanders. They typically have moist skin and undergo metamorphosis.", ipa: "/√¶mÀàf…™bi…ônz/" }
];

// Task 2: Filling in the gaps
const t2_data = [
    { 
        q: "1. After the wedding, the couple went on their ______ to Australia.", 
        ans: "honeymoon", 
        hint: "A honeymoon is the traditional vacation taken by newly married couples. The sentence describes what couples do after a wedding.",
        wordBankIndex: 5
    },
    { 
        q: "2. Frogs are ______ because they can live both on land and in water.", 
        ans: "amphibians", 
        hint: "Frogs are classic examples of amphibians. They start life in water as tadpoles and later develop to live on land.",
        wordBankIndex: 10
    },
    { 
        q: "3. Steve Irwin was a ______ wildlife expert admired around the world.", 
        ans: "well-known", 
        hint: "Steve Irwin, also known as 'The Crocodile Hunter', was famous internationally for his wildlife documentaries and conservation work.",
        wordBankIndex: 1
    },
    { 
        q: "4. His parents helped ______ a deep respect for animals in him.", 
        ans: "instill", 
        hint: "To instill means to gradually establish a quality or value in someone. Irwin's parents taught him to respect animals from a young age.",
        wordBankIndex: 7
    },
    { 
        q: "5. Dolphins and whales belong to the group of ______.", 
        ans: "mammals", 
        hint: "Dolphins and whales are marine mammals. Like all mammals, they are warm-blooded, breathe air, and nurse their young with milk.",
        wordBankIndex: 3
    },
    { 
        q: "6. A ______ is a dangerous sea animal with a long tail used for defence.", 
        ans: "stingray", 
        hint: "A stingray has a venomous barb on its tail that it uses for defense. Steve Irwin died from a stingray injury to the chest.",
        wordBankIndex: 9
    },
    { 
        q: "7. Snakes and crocodiles are classified as ______.", 
        ans: "reptiles", 
        hint: "Snakes and crocodiles are both reptiles. Reptiles are characterized by scaly skin and being cold-blooded.",
        wordBankIndex: 2
    },
    { 
        q: "8. The young keeper showed great ______ for protecting wildlife.", 
        ans: "passion", 
        hint: "Passion means strong enthusiasm or dedication. Wildlife conservation requires passion to overcome challenges.",
        wordBankIndex: 6
    },
    { 
        q: "9. The zoo was started by his parents, and he later decided to ______ it.", 
        ans: "take over", 
        hint: "Take over means to assume control or responsibility. Irwin took over management of the Australia Zoo from his parents.",
        wordBankIndex: 4
    },
    { 
        q: "10. A ______ can grow very large and kill its prey by squeezing it.", 
        ans: "python", 
        hint: "Pythons are constrictor snakes that kill by coiling around their prey and squeezing. They can grow to enormous sizes.",
        wordBankIndex: 0
    },
    { 
        q: "11. She is an ______ student with outstanding academic results.", 
        ans: "exceptional", 
        hint: "Exceptional means unusually good or outstanding. The sentence describes a student who performs better than average.",
        wordBankIndex: 8
    }
];

// Task 2 Word Bank
const t2_wordBank = [
    "python", "well-known", "reptiles", "mammals", "take over", 
    "honeymoon", "passion", "instill", "exceptional", "stingray", "amphibians"
];

// Task 3: Past Simple & Past Progressive
const t3_data = [
    { 
        q: "1. When Martin ______ (arrive) home, Ann ______ (talk) to someone on the phone.", 
        ans: "arrived|was talking", 
        hint: "Use Past Simple for the completed action (arrive) and Past Progressive for the action in progress (talk). Past Progressive often describes background actions." 
    },
    { 
        q: "2. It ______ (be) cold when we ______ (leave) the house that day, and a light snow ______ (fall).", 
        ans: "was|left|was falling", 
        hint: "Use Past Simple for completed actions (be, leave) and Past Progressive for the ongoing weather condition (fall). 'Was falling' describes snow in progress." 
    },
    { 
        q: "3. I ______ (call) Roger at nine last night, but he ______ (not / be) at home. He ______ (study) at the library.", 
        ans: "called|was not|was studying", 
        hint: "Use Past Simple for the completed call, Past Simple negative for his absence, and Past Progressive for the ongoing activity at a specific time." 
    },
    { 
        q: "4. I ______ (see) Sue in town yesterday, but she ______ (not / see) me. She ______ (look) the other way.", 
        ans: "saw|did not see|was looking", 
        hint: "Use Past Simple for completed actions (see, not see) and Past Progressive for the ongoing action (look) that explains why she didn't notice you." 
    },
    { 
        q: "5. When I ______ (open) the cupboard door, a pile of books ______ (fall) out.", 
        ans: "opened|fell", 
        hint: "Both actions are completed, so use Past Simple for both. The second action happened immediately after the first." 
    },
    { 
        q: "6. A: How ______ (you / break) your arm? B: I ______ (slip) on the ice while I ______ (cross) the street in front of the dorm.", 
        ans: "did you break|slipped|was crossing", 
        hint: "Use Past Simple for questions about completed actions (break), Past Simple for the main action (slip), and Past Progressive for the background action (cross) that was interrupted." 
    }
];

// Task 4: Past Simple & Past Perfect
const t4_data = [
    { 
        q: "1. The house was very quiet when I ______ (get) home. Everybody ______ (go) to bed.", 
        ans: "got|had gone", 
        hint: "Use Past Simple for the first action (get) and Past Perfect for the earlier completed action (go). The going to bed happened before the arrival." 
    },
    { 
        q: "2. The apartment was hot when I got home, so I ______ (turn) on the air conditioner.", 
        ans: "turned", 
        hint: "Only one past action here, so use Past Simple. The turning on happened after the arrival." 
    },
    { 
        q: "3. A: ______ (you / meet) Tom at the party last night? B: No, he ______ (already / go) home when I ______ (arrive) at the party.", 
        ans: "Did you meet|had already gone|arrived", 
        hint: "Use Past Simple for the question and the later action (arrive), and Past Perfect for the earlier action (go) that was completed before the arrival." 
    },
    { 
        q: "4. I ______ (feel) a little better after I ______ (take) the medicine.", 
        ans: "felt|had taken", 
        hint: "Use Past Simple for the later feeling and Past Perfect for the earlier action (take). The medicine was taken before the improvement." 
    },
    { 
        q: "5. I was late. The teacher ______ (already / give) a quiz when I ______ (get) to class.", 
        ans: "had already given|got", 
        hint: "Use Past Perfect for the earlier completed action (give) and Past Simple for the later action (get). The quiz was already given before arrival." 
    },
    { 
        q: "6. It was raining hard, but by the time the class ______ (be) over, the rain ______ (stop).", 
        ans: "was|had stopped", 
        hint: "Use Past Simple for the state (be) and Past Perfect for the earlier completed action (stop). The rain stopped before the class ended." 
    }
];

// Task 5: Phrasal Verbs ‚Äì Choose the correct option (UPDATED WITH 3 OPTIONS)
const t5_data = [
    { 
        q: "1. After his father retired, Steve decided to <span class='bold-option'>took off</span> / <span class='bold-option'>take on</span> / <span class='bold-option'>take over</span> the family wildlife park.", 
        ans: "take over", 
        hint: "'Take over' means to assume control or responsibility. Steve took control of the wildlife park from his father.",
        options: ["took off", "take on", "take over"]
    },
    { 
        q: "2. Steve's television career really <span class='bold-option'>took off</span> / <span class='bold-option'>take on</span> / <span class='bold-option'>took after</span> the success of his first documentary series.", 
        ans: "took off", 
        hint: "'Take off' means to become successful or popular. His career became successful after his first documentary.",
        options: ["took off", "take on", "took after"]
    },
    { 
        q: "3. She decided to <span class='bold-option'>take up</span> / <span class='bold-option'>take over</span> / <span class='bold-option'>took off</span> photography as a hobby during her free time.", 
        ans: "take up", 
        hint: "'Take up' means to start a new hobby or activity. Photography is a hobby she started.",
        options: ["take up", "take over", "took off"]
    },
    { 
        q: "4. Steve was named after his father, whom he greatly <span class='bold-option'>took up</span> / <span class='bold-option'>took off</span> / <span class='bold-option'>took after</span>.", 
        ans: "took after", 
        hint: "'Take after' means to resemble or have similar qualities to a family member. Steve resembled his father.",
        options: ["took up", "took off", "took after"]
    },
    { 
        q: "5. The plane <span class='bold-option'>took after</span> / <span class='bold-option'>took off</span> / <span class='bold-option'>took over</span> safely at 6 a.m., despite the bad weather.", 
        ans: "took off", 
        hint: "'Take off' means to leave the ground (for aircraft). The plane left the ground despite bad weather.",
        options: ["took after", "took off", "took over"]
    }
];

/* --- GLOBAL STATE --- */
let currentActiveIPA = null;
let answerStates = new Map();
let wordUsageCount = {};
let optionSelections = new Map(); // Stores user selections for Task 5

/* --- RENDERING FUNCTIONS --- */

function renderMatching(id, data) {
    const v = document.getElementById(`vocab-${id}`); 
    const d = document.getElementById(`def-${id}`);
    
    v.innerHTML = '';
    d.innerHTML = '';
    
    const definitions = {};
    data.forEach(item => {
        definitions[item.letter] = item.def;
    });
    
    const sortedLetters = Object.keys(definitions).sort();
    sortedLetters.forEach(letter => {
        d.innerHTML += `
            <div class="definition-item">
                <span class="definition-letter">${letter}.</span>
                <span class="definition-text">${definitions[letter]}</span>
            </div>`;
    });
    
    data.forEach((item, i) => {
        const qid = `${id}-q${i}`;
        
        v.innerHTML += `
            <div class="vocab-item">
                <span class="vocab-text">${item.v}</span>
                <input type="text" class="letter-input" id="${qid}" data-type="input" data-ans="${item.letter}" maxlength="1" oninput="adjustWidth(this)">
                <div class="row-btns">
                    <button class="btn-small" id="${qid}-eye" onclick="toggleSingleAns('${qid}')" title="Show/Hide answer">üëÅÔ∏è</button>
                    <button class="btn-small speaker-btn" onclick="toggleIPA('${qid}')" title="Show pronunciation">üîä</button>
                    <button class="info-btn" id="${qid}-info" onclick="toggleHint('${qid}')" title="Show/Hide hint">i</button>
                </div>
                <div class="hint-box" id="${qid}-hint">üí° ${item.hint}</div>
                <div class="ipa-box" id="${qid}-ipa">
                    <span class="ipa-label">IPA:</span>
                    <span class="ipa-text">${item.ipa}</span>
                </div>
            </div>`;
    });
}

function renderGapFillWithWordBank(id, data, wordBank) {
    const container = document.getElementById(`questions-${id}`);
    const bankContainer = document.getElementById(`bank-${id}`);
    
    container.innerHTML = '';
    bankContainer.innerHTML = '';
    
    wordUsageCount[id] = {};
    wordBank.forEach(word => {
        wordUsageCount[id][word] = 0;
    });
    
    wordBank.forEach((word, i) => {
        const wordId = `${id}-word-${i}`;
        bankContainer.innerHTML += `
            <div class="word-item" id="${wordId}" data-word="${word}" draggable="true" ondragstart="dragWord(event)" onclick="selectWordFromBank('${wordId}')">
                ${word.toLowerCase()}
            </div>`;
    });
    
    data.forEach((it, i) => {
        const qid = `${id}-q${i}`;
        
        let sentence = it.q;
        let numberHtml = '';
        const numberMatch = sentence.match(/^(\d+)\.\s+/);
        
        if (numberMatch) {
            sentence = sentence.replace(/^\d+\.\s+/, '');
            numberHtml = `<span class="existing-number">${numberMatch[1]}.</span>`;
        } else {
            numberHtml = `<span class="exercise-number">${i+1}</span>`;
        }
        
        const parts = sentence.split('______');
        
        container.innerHTML += `
            <div class="question-row" id="${qid}-row">
                ${numberHtml} 
                ${parts[0]}
                <input type="text" class="word-input" id="${qid}" data-type="input" data-ans="${it.ans}" data-word-bank-index="${it.wordBankIndex}" oninput="adjustWidth(this); updateWordBank('${id}')" ondrop="dropWord(event, '${qid}')" ondragover="allowDrop(event)" onclick="this.select()">
                ${parts[1]}
                <div class="row-btns">
                    <button class="btn-small" id="${qid}-eye" onclick="toggleSingleAns('${qid}')">üëÅÔ∏è</button>
                    <button class="info-btn" id="${qid}-info" onclick="toggleHint('${qid}')">i</button>
                </div>
                <div class="hint-box" id="${qid}-hint">üí° ${it.hint}</div>
            </div>`;
    });
    
    addWordBankEventListeners(id);
}

function renderPastTenses(id, data) {
    const container = document.getElementById(`questions-${id}`);
    
    container.innerHTML = '';
    
    data.forEach((it, i) => {
        const qid = `${id}-q${i}`;
        
        let sentence = it.q;
        let numberHtml = '';
        const numberMatch = sentence.match(/^(\d+)\.\s+/);
        
        if (numberMatch) {
            sentence = sentence.replace(/^\d+\.\s+/, '');
            numberHtml = `<span class="existing-number">${numberMatch[1]}.</span>`;
        } else {
            numberHtml = `<span class="exercise-number">${i+1}</span>`;
        }
        
        const gaps = sentence.match(/______/g);
        let renderedSentence = sentence;
        
        if (gaps) {
            const answers = it.ans.split('|');
            
            for (let j = 0; j < gaps.length; j++) {
                const gapId = `${qid}-gap${j}`;
                const answerForGap = answers[j] || answers[0];
                renderedSentence = renderedSentence.replace('______', 
                    `<input type="text" class="verb-input" id="${gapId}" data-type="input" data-ans="${answerForGap}" oninput="adjustWidth(this)">`);
            }
        }
        
        container.innerHTML += `
            <div class="question-row">
                ${numberHtml} 
                <span class="tense-sentence">
                    ${renderedSentence}
                </span>
                <div class="row-btns">
                    <button class="btn-small" id="${qid}-eye" onclick="toggleSingleAns('${qid}')">üëÅÔ∏è</button>
                    <button class="info-btn" id="${qid}-info" onclick="toggleHint('${qid}')">i</button>
                </div>
                <div class="hint-box" id="${qid}-hint">üí° ${it.hint}</div>
            </div>`;
    });
}

function renderPhrasalVerbs(id, data) {
    const container = document.getElementById(`questions-${id}`);
    
    container.innerHTML = '';
    
    data.forEach((it, i) => {
        const qid = `${id}-q${i}`;
        
        let sentence = it.q;
        let numberHtml = '';
        const numberMatch = sentence.match(/^(\d+)\.\s+/);
        
        if (numberMatch) {
            sentence = sentence.replace(/^\d+\.\s+/, '');
            numberHtml = `<span class="existing-number">${numberMatch[1]}.</span>`;
        } else {
            numberHtml = `<span class="exercise-number">${i+1}</span>`;
        }
        
        // Create option buttons
        let optionsHtml = '';
        it.options.forEach((option, optIndex) => {
            optionsHtml += `<button class="option-btn" onclick="selectOption('${qid}', '${option}')" id="${qid}-opt${optIndex}">${option}</button>`;
        });
        
        container.innerHTML += `
            <div class="question-row">
                ${numberHtml} 
                <span class="tense-sentence">
                    ${sentence}
                    <div class="option-container">
                        ${optionsHtml}
                    </div>
                </span>
                <div class="row-btns">
                    <button class="btn-small" id="${qid}-eye" onclick="toggleSingleAns('${qid}')">üëÅÔ∏è</button>
                    <button class="info-btn" id="${qid}-info" onclick="toggleHint('${qid}')">i</button>
                </div>
                <div class="hint-box" id="${qid}-hint">üí° ${it.hint}</div>
            </div>`;
    });
}

/* --- UTILITY FUNCTIONS --- */

function adjustWidth(el) { 
    let baseWidth;
    if (el.classList.contains('letter-input')) {
        baseWidth = 45;
    } else if (el.classList.contains('verb-input')) {
        baseWidth = 80;
    } else if (el.classList.contains('word-input')) {
        baseWidth = 120;
    } else if (el.classList.contains('grammar-input')) {
        baseWidth = 150;
    } else {
        baseWidth = 60;
    }
    
    let charWidth;
    if (el.classList.contains('word-input') || el.classList.contains('grammar-input')) {
        charWidth = 9;
    } else {
        charWidth = 10;
    }
    
    const newWidth = Math.max(el.value.length * charWidth + 20, baseWidth);
    
    let maxWidth;
    if (el.classList.contains('letter-input')) {
        maxWidth = 80;
    } else if (el.classList.contains('verb-input')) {
        maxWidth = 200;
    } else if (el.classList.contains('word-input')) {
        maxWidth = 400;
    } else if (el.classList.contains('grammar-input')) {
        maxWidth = 500;
    } else {
        maxWidth = 300;
    }
    
    el.style.width = Math.min(newWidth, maxWidth) + "px";
}

function toggleHint(id) { 
    const h = document.getElementById(id + '-hint'); 
    const infoBtn = document.getElementById(id + '-info');
    
    if (h) {
        if (h.style.display === 'block') {
            h.style.display = 'none';
            if (infoBtn) infoBtn.classList.remove('active');
        } else {
            h.style.display = 'block';
            if (infoBtn) infoBtn.classList.add('active');
        }
    }
}

function toggleIPA(id) { 
    const ipaBox = document.getElementById(id + '-ipa'); 
    const speakerBtn = document.querySelector(`button[onclick="toggleIPA('${id}')"]`);
    
    if (currentActiveIPA === ipaBox) {
        ipaBox.style.display = 'none';
        currentActiveIPA = null;
        if (speakerBtn) speakerBtn.classList.remove('active');
        return;
    }
    
    if (currentActiveIPA) {
        const prevSpeakerBtn = document.querySelector(`button[onclick*="${currentActiveIPA.id.replace('-ipa', '')}"]`);
        if (prevSpeakerBtn) prevSpeakerBtn.classList.remove('active');
        currentActiveIPA.style.display = 'none';
    }
    
    if (ipaBox) {
        ipaBox.style.display = 'block';
        currentActiveIPA = ipaBox;
        if (speakerBtn) speakerBtn.classList.add('active');
    }
}

/* --- FIXED: TOGGLE SINGLE ANSWER FOR MULTI-GAP QUESTIONS (TASK 3 & 4) --- */
function toggleSingleAns(id) { 
    // Check if this is a Task 5 eye button
    if (id.startsWith('t5')) {
        showOptionAnswer(id);
        return;
    }
    
    // Extract question prefix (e.g., "t3-q0" from "t3-q0-eye")
    const questionPrefix = id.replace('-eye', '');
    const eyeBtn = document.getElementById(id);
    
    // Check if this question has multiple gaps (Task 3 & 4 format)
    // Look for input fields that start with the question prefix
    const inputFields = document.querySelectorAll(`[id^="${questionPrefix}-gap"]`);
    
    // Get the state key
    const stateKey = `${questionPrefix}-state`;
    const isCurrentlyShown = answerStates.get(stateKey) || false;
    
    if (inputFields.length > 0) {
        // This is a multi-gap question (Task 3 or 4)
        if (isCurrentlyShown) {
            // Hide all answers
            inputFields.forEach(input => {
                input.value = "";
                input.classList.remove('correct', 'incorrect-marked', 'long-answer');
                adjustWidth(input);
            });
            if (eyeBtn) eyeBtn.classList.remove('active');
            answerStates.set(stateKey, false);
        } else {
            // Show all answers
            inputFields.forEach((input, index) => {
                const ans = input.dataset.ans;
                if (ans) {
                    const firstAns = ans.split('|')[0];
                    input.value = firstAns;
                    input.classList.add('correct');
                    input.classList.remove('incorrect-marked');
                    adjustWidth(input);
                }
            });
            if (eyeBtn) eyeBtn.classList.add('active');
            answerStates.set(stateKey, true);
        }
    } else {
        // This is a single-input question (Task 1 or 2)
        const el = document.getElementById(questionPrefix);
        if (!el) return;
        
        const ans = el.dataset.ans;
        
        if (isCurrentlyShown) {
            el.value = "";
            el.classList.remove('correct', 'incorrect-marked', 'long-answer');
            adjustWidth(el);
            if (eyeBtn) eyeBtn.classList.remove('active');
            answerStates.set(stateKey, false);
        } else {
            if (ans) {
                const firstAns = ans.split('|')[0];
                el.value = firstAns;
                el.classList.add('correct');
                el.classList.remove('incorrect-marked');
                
                adjustWidth(el);
                if (eyeBtn) eyeBtn.classList.add('active');
                answerStates.set(stateKey, true);
            }
        }
    }
}

function showOptionAnswer(id) {
    const qid = id.replace('-eye', '');
    const questionIndex = parseInt(qid.split('-q')[1]);
    const questionData = t5_data[questionIndex];
    const correctAnswer = questionData.ans;
    
    // Get all option buttons for this question
    const optionButtons = [];
    for (let i = 0; i < 3; i++) {
        const btn = document.getElementById(`${qid}-opt${i}`);
        if (btn) optionButtons.push(btn);
    }
    
    // Clear all colors first (but keep selection)
    optionButtons.forEach(btn => {
        btn.classList.remove('correct-option', 'incorrect-option');
    });
    
    // Highlight correct answer
    optionButtons.forEach(btn => {
        if (btn.textContent === correctAnswer) {
            btn.classList.add('correct-option');
        }
    });
    
    const eyeBtn = document.getElementById(id);
    if (eyeBtn) eyeBtn.classList.add('active');
    
    answerStates.set(`${qid}-state`, true);
}

function showAnswers(prefix) { 
    if (prefix === 't5') {
        t5_data.forEach((item, i) => {
            const qid = `${prefix}-q${i}`;
            const correctAnswer = item.ans;
            
            // Get all option buttons for this question
            const optionButtons = [];
            for (let j = 0; j < 3; j++) {
                const btn = document.getElementById(`${qid}-opt${j}`);
                if (btn) optionButtons.push(btn);
            }
            
            // Clear all colors first (but keep selection)
            optionButtons.forEach(btn => {
                btn.classList.remove('correct-option', 'incorrect-option');
            });
            
            // Highlight correct answer
            optionButtons.forEach(btn => {
                if (btn.textContent === correctAnswer) {
                    btn.classList.add('correct-option');
                }
            });
            
            const eyeBtn = document.getElementById(`${qid}-eye`);
            if (eyeBtn) eyeBtn.classList.add('active');
            answerStates.set(`${qid}-state`, true);
        });
        return;
    }
    
    // Handle Task 3 & 4 (multi-gap questions)
    if (prefix === 't3' || prefix === 't4') {
        const data = prefix === 't3' ? t3_data : t4_data;
        
        data.forEach((item, i) => {
            const qid = `${prefix}-q${i}`;
            const answers = item.ans.split('|');
            
            // Find all input fields for this question
            const inputFields = [];
            for (let j = 0; j < answers.length; j++) {
                const inputId = `${qid}-gap${j}`;
                const input = document.getElementById(inputId);
                if (input) {
                    inputFields.push(input);
                }
            }
            
            // Fill all gaps with answers
            inputFields.forEach((input, index) => {
                const answer = answers[index] || answers[0];
                input.value = answer;
                input.classList.add('correct');
                input.classList.remove('incorrect-marked');
                adjustWidth(input);
            });
            
            // Activate eye button
            const eyeBtn = document.getElementById(`${qid}-eye`);
            if (eyeBtn) eyeBtn.classList.add('active');
            answerStates.set(`${qid}-state`, true);
        });
        return;
    }
    
    // Handle Task 1 & 2 (single-input questions)
    document.querySelectorAll(`[id^="${prefix}-q"]`).forEach(el => {
        if (el.dataset.type === 'input') {
            const stateKey = `${el.id}-state`;
            const ans = el.dataset.ans;
            const eyeBtn = document.getElementById(el.id + '-eye');
            
            if (ans) {
                const firstAns = ans.split('|')[0];
                el.value = firstAns;
                el.classList.add('correct');
                el.classList.remove('incorrect-marked');
                
                adjustWidth(el);
                if (eyeBtn) eyeBtn.classList.add('active');
                answerStates.set(stateKey, true);
            }
        }
    });
}

/* --- FIXED: TASK 5 RESET FUNCTION - COMPLETE STYLING RESET --- */
function resetSection(prefix) { 
    // Reset input fields
    document.querySelectorAll(`[id^="${prefix}"]`).forEach(i => { 
        if(i.tagName === 'INPUT') { 
            i.value = ""; 
            i.classList.remove('correct', 'incorrect-marked', 'long-answer'); 
            adjustWidth(i); 
        } 
        const hBox = document.getElementById(i.id + '-hint'); 
        if(hBox) hBox.style.display = 'none'; 
        const ipaBox = document.getElementById(i.id + '-ipa');
        if(ipaBox) ipaBox.style.display = 'none';
    });
    
    // Reset buttons
    document.querySelectorAll(`[id$="-eye"], [id$="-info"]`).forEach(btn => {
        if (btn.id.includes(prefix)) {
            btn.classList.remove('active');
        }
    });
    
    // Reset IPA
    if (currentActiveIPA) {
        const speakerBtn = document.querySelector(`button[onclick*="${currentActiveIPA.id.replace('-ipa', '')}"]`);
        if (speakerBtn) speakerBtn.classList.remove('active');
        currentActiveIPA = null;
    }
    
    // Reset answer states
    for (const [key, value] of answerStates.entries()) {
        if (key.startsWith(`${prefix}-`)) {
            answerStates.delete(key);
        }
    }
    
    // Task 2 specific reset
    if (prefix === 't2') {
        const wordItems = document.querySelectorAll('#bank-t2 .word-item');
        wordItems.forEach(item => {
            item.classList.remove('used');
            item.style.display = 'flex';
        });
        
        if (wordUsageCount['t2']) {
            Object.keys(wordUsageCount['t2']).forEach(word => {
                wordUsageCount['t2'][word] = 0;
            });
        }
    }
    
    /* --- TASK 5 RESET FIX: COMPLETE VISUAL RESET --- */
    if (prefix === 't5') {
        // Select ALL option buttons in Task 5 using querySelector
        const allOptionBtns = document.querySelectorAll('#questions-t5 .option-btn');
        
        allOptionBtns.forEach(btn => {
            // Remove ALL color-related classes
            btn.classList.remove('selected', 'correct-option', 'incorrect-option');
            
            // CRITICAL FIX: Clear all inline styles
            // This forces browser to reapply original CSS styles
            btn.style.cssText = '';
            
            // Additional safety: explicitly set original styles
            btn.style.background = '';
            btn.style.backgroundColor = '';
            btn.style.color = '';
            btn.style.borderColor = '';
            btn.style.border = '';
        });
        
        // Clear all selections from memory
        for (const [key, value] of optionSelections.entries()) {
            if (key.startsWith(`${prefix}-`)) {
                optionSelections.delete(key);
            }
        }
        
        // Reset eye buttons to inactive state
        document.querySelectorAll('#questions-t5 .btn-small[id$="-eye"]').forEach(eyeBtn => {
            eyeBtn.classList.remove('active');
        });
        
        // Clear answer states for Task 5
        for (const [key, value] of answerStates.entries()) {
            if (key.includes('t5-q')) {
                answerStates.delete(key);
            }
        }
    }
}

function normalizeAnswer(answer) {
    return answer.toLowerCase()
        .trim()
        .replace(/\s+/g, ' ')
        .replace(/[.,;:!?]$/, '');
}

function validateMultipleAnswers(userAnswer, correctAnswers) {
    const answers = correctAnswers.split('|').map(ans => normalizeAnswer(ans));
    const normalizedUser = normalizeAnswer(userAnswer);
    
    return answers.some(ans => ans === normalizedUser);
}

/* --- UPDATED: TASK 5 CHECK ALL BEHAVIOR --- */
function checkAll() { 
    // Validate Task 1-4 input fields
    document.querySelectorAll('[data-type="input"]').forEach(el => { 
        const correctAnswers = el.dataset.ans;
        const userAnswer = el.value;
        
        el.classList.remove('correct', 'incorrect-marked'); 
        
        if(!userAnswer.trim()) {
            return;
        }
        
        if(validateMultipleAnswers(userAnswer, correctAnswers)) {
            el.classList.add('correct');
        } else {
            el.classList.add('incorrect-marked');
        }
    });
    
    /* --- TASK 5: NEW BEHAVIOR --- */
    // Task 5: Check ONLY questions that have been selected
    // DO NOT automatically show correct answers
    t5_data.forEach((item, i) => {
        const qid = `t5-q${i}`;
        const selectedOption = optionSelections.get(qid);
        const correctAnswer = item.ans;
        
        // If user has NOT selected an option, DO NOTHING
        if (!selectedOption) {
            return; // Skip this question entirely
        }
        
        // Get all option buttons for this question
        const optionButtons = [];
        for (let j = 0; j < 3; j++) {
            const btn = document.getElementById(`${qid}-opt${j}`);
            if (btn) optionButtons.push(btn);
        }
        
        // Clear previous check colors for THIS QUESTION ONLY
        optionButtons.forEach(btn => {
            btn.classList.remove('correct-option', 'incorrect-option');
        });
        
        // IMPORTANT: DO NOT automatically highlight the correct answer
        // Only mark the user's selection as correct/incorrect
        
        // Find and mark the user's selected option
        const userSelectedBtn = optionButtons.find(btn => btn.textContent === selectedOption);
        if (userSelectedBtn) {
            if (selectedOption === correctAnswer) {
                // User selected correctly: mark in green
                userSelectedBtn.classList.add('correct-option');
            } else {
                // User selected incorrectly: mark in red
                userSelectedBtn.classList.add('incorrect-option');
                
                // Optionally, you could show the correct answer here
                // But per requirements, we DON'T show correct answer automatically
                // Uncomment below if you want to show correct when user is wrong:
                // const correctBtn = optionButtons.find(btn => btn.textContent === correctAnswer);
                // if (correctBtn) correctBtn.classList.add('correct-option');
            }
        }
    });
}

/* --- TASK 5 SPECIFIC FUNCTIONS --- */

function selectOption(qid, option) {
    const questionIndex = parseInt(qid.split('-q')[1]);
    const questionData = t5_data[questionIndex];
    
    // Get all option buttons for this question
    const optionButtons = [];
    for (let i = 0; i < 3; i++) {
        const btn = document.getElementById(`${qid}-opt${i}`);
        if (btn) optionButtons.push(btn);
    }
    
    // Remove 'selected' class from all options
    optionButtons.forEach(btn => {
        btn.classList.remove('selected');
    });
    
    // Add 'selected' class to clicked option
    const selectedBtn = optionButtons.find(btn => btn.textContent === option);
    if (selectedBtn) {
        selectedBtn.classList.add('selected');
    }
    
    // Save the selection
    optionSelections.set(qid, option);
    
    // Do NOT auto-check - wait for Check All or Enter
    // Only visual feedback is the 'selected' class (blue background)
}

/* --- WORD BANK FUNCTIONS --- */

function addWordBankEventListeners(id) {
    const wordItems = document.querySelectorAll(`#bank-${id} .word-item`);
    const inputs = document.querySelectorAll(`#questions-${id} input.word-input`);
    
    wordItems.forEach(item => {
        item.addEventListener('click', function() {
            selectWordFromBank(this.id);
        });
        
        item.addEventListener('dragstart', function(e) {
            dragWord(e);
        });
    });
    
    inputs.forEach(input => {
        input.addEventListener('dragover', function(e) {
            allowDrop(e);
        });
        
        input.addEventListener('drop', function(e) {
            dropWord(e, this.id);
        });
    });
}

function dragWord(event) {
    event.dataTransfer.setData("text/plain", event.target.dataset.word);
    event.dataTransfer.setData("wordId", event.target.id);
}

function allowDrop(event) {
    event.preventDefault();
}

function dropWord(event, inputId) {
    event.preventDefault();
    const word = event.dataTransfer.getData("text/plain");
    const wordId = event.dataTransfer.getData("wordId");
    
    const input = document.getElementById(inputId);
    if (input) {
        input.value = word;
        adjustWidth(input);
        
        updateWordBankUsage(word, inputId.split('-')[0]);
    }
}

function selectWordFromBank(wordId) {
    const wordItem = document.getElementById(wordId);
    if (!wordItem) return;
    
    const word = wordItem.dataset.word;
    const taskId = wordId.split('-')[1];
    
    const inputs = document.querySelectorAll(`#questions-t${taskId} input.word-input`);
    let emptyInput = null;
    
    for (const input of inputs) {
        if (!input.value.trim()) {
            emptyInput = input;
            break;
        }
    }
    
    if (emptyInput) {
        emptyInput.value = word;
        adjustWidth(emptyInput);
        
        updateWordBankUsage(word, `t${taskId}`);
    } else {
        alert('All gaps are filled. You can click on a gap to replace its content.');
    }
}

function updateWordBankUsage(word, taskId) {
    if (!wordUsageCount[taskId]) {
        wordUsageCount[taskId] = {};
    }
    
    if (!wordUsageCount[taskId][word]) {
        wordUsageCount[taskId][word] = 0;
    }
    
    const inputs = document.querySelectorAll(`#questions-${taskId} input.word-input`);
    let count = 0;
    
    inputs.forEach(input => {
        if (normalizeAnswer(input.value) === normalizeAnswer(word)) {
            count++;
        }
    });
    
    wordUsageCount[taskId][word] = count;
    
    updateWordBankDisplay(taskId);
}

function updateWordBankDisplay(taskId) {
    const wordItems = document.querySelectorAll(`#bank-${taskId} .word-item`);
    
    wordItems.forEach(item => {
        const word = item.dataset.word;
        const count = wordUsageCount[taskId][word] || 0;
        
        if (count > 0) {
            item.classList.add('used');
        } else {
            item.classList.remove('used');
        }
    });
}

function updateWordBank(taskId) {
    const inputs = document.querySelectorAll(`#questions-${taskId} input.word-input`);
    
    if (wordUsageCount[taskId]) {
        Object.keys(wordUsageCount[taskId]).forEach(word => {
            wordUsageCount[taskId][word] = 0;
        });
    }
    
    inputs.forEach(input => {
        const word = input.value.trim();
        if (word) {
            const wordItems = document.querySelectorAll(`#bank-${taskId} .word-item`);
            let foundWord = null;
            
            wordItems.forEach(item => {
                if (normalizeAnswer(item.dataset.word) === normalizeAnswer(word)) {
                    foundWord = item.dataset.word;
                }
            });
            
            if (foundWord && wordUsageCount[taskId][foundWord] !== undefined) {
                wordUsageCount[taskId][foundWord]++;
            }
        }
    });
    
    updateWordBankDisplay(taskId);
}

/* --- INITIALIZATION --- */

window.onload = () => {
    renderMatching('t1', t1_data);
    renderGapFillWithWordBank('t2', t2_data, t2_wordBank);
    renderPastTenses('t3', t3_data);
    renderPastTenses('t4', t4_data);
    renderPhrasalVerbs('t5', t5_data);
};

/* --- KEYBOARD SUPPORT --- */

document.addEventListener('keydown', e => { 
    if(e.key === 'Enter') {
        checkAll(); 
    }
});

/* --- ADDITIONAL NOTES --- */

// IMPORTANT: When creating new code based on this template:
// 1. Preserve ALL technical requirement comments above
// 2. Add new requirements as additional numbered points
// 3. Maintain the same CSS structure and JavaScript architecture
// 4. Keep all existing functionality while adding new features
// 5. Test all interactive elements after modifications
// 6. Document any algorithm changes in the technical requirements section

// KEY CASE HANDLING RULES:
// 1. Word bank items: Always displayed in lowercase for visual consistency
// 2. Answer display: Show exact 'ans' property from data (preserves original case)
// 3. Validation: Uses normalizeAnswer() for case-insensitive comparison
// 4. User experience: No automatic case modification during input
// 5. This ensures proper nouns are displayed correctly when shown

// GAP DETECTION RULE:
// 1. Any occurrence of "______" (2 or more underscores) is automatically replaced
// 2. This handles variations in gap length from different sources
// 3. Input fields are inserted exactly where the underscores appear

// MATCHING EXERCISE TWO-COLUMN LAYOUT WITH IPA:
// 1. Left column: Vocabulary items with input boxes for matching letters
// 2. Right column: Definitions in alphabetical order (A, B, C, D, etc.) in a styled column
// 3. Each vocabulary item has three control buttons:
//    - üëÅÔ∏è Eye button (28x28px): Shows the correct answer
//    - üîä Speaker button (28x28px): Shows IPA pronunciation from authoritative dictionary
//    - (i) Info button (20x20px): Shows pedagogical hint
// 4. IPA pronunciation data comes from reliable dictionary sources (Oxford, Cambridge, Merriam-Webster)
// 5. IPA display appears in a dedicated box below each vocabulary item with distinct styling

// IPA SINGLE ACTIVE DISPLAY SYSTEM:
// 1. Only ONE IPA pronunciation box can be visible at a time across the entire application
// 2. Clicking a speaker button shows that word's IPA and automatically hides any other visible IPA box
// 3. Clicking the same speaker button again toggles (hides) its own IPA box
// 4. Global state variable (currentActiveIPA) tracks the currently active IPA box
// 5. This prevents visual clutter and ensures a clean, uncluttered interface

// DEFINITIONS COLUMN OPTIMIZATION:
// 1. Definitions column displays clean list without unnecessary headers or titles
// 2. Alphabetical ordering (A, B, C, D) maintained for easy reference
// 3. Visual hierarchy maintained through consistent styling and spacing
// 4. Column alignment optimized for readability and space efficiency
// 5. Clean, minimal design that focuses on content rather than decoration

// SCROLLABLE DEFINITIONS COLUMN FOR MATCHING EXERCISES:
// 1. Definitions column has independent vertical scrolling when content is too long
// 2. Fixed height (500px) with overflow-y: auto enables scrolling within the column
// 3. Custom scrollbar styling matches the design system with subtle appearance
// 4. Allows users to scroll through definitions while keeping vocabulary column fixed
// 5. Particularly useful when definitions are long or numerous
// 6. Scrollbar appears only when needed (auto overflow)

// WORD BANK MANAGEMENT FOR GAP-FILL EXERCISES:
// 1. Word bank appears in a sticky container at the top of Task 2
// 2. Words can be clicked or dragged and dropped into input fields
// 3. Used words are automatically hidden from the bank
// 4. Word usage is tracked to handle duplicate answers correctly
// 5. Users can also type directly into input fields

// RELATIVE CLAUSES EXERCISE FORMAT:
// 1. Special input type for relative pronouns with appropriate width
// 2. Multiple correct answers supported (e.g., "which|that")
// 3. Detailed grammar explanations in hints

// PASSIVE VOICE TRANSFORMATION:
// 1. Requires students to rewrite sentences in passive form
// 2. Includes tense preservation in the transformation
// 3. Comprehensive grammar explanations for passive voice formation

// ADJECTIVE/ADVERB COMPARATIVE FORMS:
// 1. Exercises for comparative (-er) and superlative (-est) forms
// 2. Includes "as...as" structure for equal comparisons
// 3. Handles regular and irregular forms appropriately

// SO/SUCH/ENOUGH STRUCTURES:
// 1. Practice with intensifiers and result clauses
// 2. Different grammatical structures (so + adj, such + noun, adj + enough)
// 3. Clear explanations for when to use each structure

// ADAPTIVE INPUT WIDTH EXPANSION:
// 1. Input fields automatically expand to show complete text content
// 2. Different character width multipliers for different input types:
//    - Short inputs (letter-input): 10px per character
//    - Medium inputs (word-input, grammar-input): 9px per character
//    - Long inputs (passive-input): 8px per character for better fit
// 3. Maximum width limits prevent excessive expansion:
//    - Letter inputs: max 80px
//    - Relative pronoun inputs: max 200px
//    - Adjective inputs: max 300px
//    - Word inputs: max 400px
//    - Passive voice inputs: max 600px (extra wide for long sentences)
//    - Grammar inputs: max 500px
// 4. Minimum widths ensure usability for empty fields
// 5. Special handling for very long answers (e.g., "most environmentally friendly"):
//    - Reduces font size slightly for better fit
//    - Uses smaller character width calculation
// 6. The adjustWidth() function dynamically recalculates on every input event
// 7. Box-sizing: border-box ensures padding is included in width calculations

// CLEAN OPTION-FORMATTING FOR PHRASAL VERB EXERCISES:
// 1. IMPORTANT FIX: Options should NOT appear within the sentence text
// 2. Sentence should show only the context with a gap, options displayed separately as buttons
// 3. For Task 5 phrasal verbs: Each sentence ends with options as clickable buttons
// 4. This prevents duplication of option text within the sentence
// 5. Algorithm: Data for Task 5 must have clean sentences without option text included
// 6. Example: "She decided to ______ photography as a hobby" + options ["take up", "take over"]
// 7. NOT: "She decided to take up / take over photography as a hobby"

// TASK 5 SELECTIVE CHECK AND COMPLETE RESET:
// 1. Check All/Enter ONLY validates questions that have been selected by the user
// 2. Questions without any selected option are COMPLETELY IGNORED during check
// 3. No color changes or answer reveals for unselected questions
// 4. Reset button completely restores option buttons to original white state:
//    - Removes 'selected' class (blue background) 
//    - Removes 'correct-option' class (green background)
//    - Removes 'incorrect-option' class (red background)
//    - Restores original background color (#eef2f7), text color, and border
// 5. Users have full control: select options, then check only what they want
// 6. This prevents "spoiling" answers for questions the user hasn't attempted yet
// 7. Show All button still works independently to reveal all correct answers

// TASK 5 ANSWER REVEAL BEHAVIOR FIX - IMPLEMENTATION DETAILS:
// 1. CHECK ALL BUTTON BEHAVIOR:
//    - For Task 5: Only validates questions that have been selected by the user
//    - If user selects correctly ‚Üí option turns GREEN
//    - If user selects incorrectly ‚Üí option turns RED
//    - Unselected questions remain completely unchanged (no colors shown)
//    - Correct answers are NOT automatically revealed
// 2. EYE BUTTON (üëÅÔ∏è) BEHAVIOR:
//    - Shows correct answer for individual question (turns correct option GREEN)
//    - Toggle functionality: click again to hide answer
// 3. SHOW ALL BUTTON BEHAVIOR:
//    - Shows ALL correct answers for Task 5 (all correct options turn GREEN)
//    - This is intentional for when user wants to see all answers
// 4. RESET BUTTON BEHAVIOR:
//    - Completely restores Task 5 to original state
//    - Removes ALL color classes (selected, correct-option, incorrect-option)
//    - Restores original CSS styling
//    - Clears all user selections from memory
// 5. PEDAGOGICAL RATIONALE:
//    - Prevents "spoiling" answers for unattempted questions
//    - Encourages active learning: user must try first
//    - Provides targeted feedback on user selections
//    - Maintains control: user decides when to see answers
// 6. TECHNICAL IMPLEMENTATION:
//    - optionSelections Map tracks user choices
//    - checkAll() only processes selections that exist in the Map
//    - No automatic highlighting of correct answers during validation
//    - Reset removes all traces of user interaction

// TASK 5 RESET FIX - STYLING PERSISTENCE ISSUE:
// 1. PROBLEM IDENTIFIED: After Check All, Reset button didn't fully restore original colors
// 2. ROOT CAUSE: Inline styles and CSS class inheritance conflicts
// 3. SOLUTION IMPLEMENTED:
//    - Use querySelectorAll to select ALL option buttons in Task 5
//    - Remove ALL color-related classes (selected, correct-option, incorrect-option)
//    - CRITICAL FIX: Use btn.style.cssText = '' to clear ALL inline styles
//    - Additional safety: Explicitly reset individual style properties
//    - Also reset eye button active states
//    - Clear all selections from memory (optionSelections Map)
// 4. RESULT: Complete visual reset to original white state as shown in image
// 5. TESTING: Reset now works correctly even after multiple Check All operations

// TASK 3 & 4 EYE BUTTON FIX FOR MULTI-GAP QUESTIONS:
// 1. PROBLEM IDENTIFIED: Eye button didn't work for Task 3 and Task 4 questions
// 2. ROOT CAUSE: Input fields have different IDs (e.g., "t3-q0-gap0", "t3-q0-gap1")
//    but toggleSingleAns() was looking for ID "t3-q0" which doesn't exist
// 3. SOLUTION IMPLEMENTED:
//    - Modified toggleSingleAns() to detect multi-gap questions
//    - Uses querySelectorAll to find all input fields with matching question prefix
//    - Shows/hides ALL gaps for a question simultaneously
//    - Maintains toggle functionality (click again to hide)
// 4. ALGORITHM:
//    a. Extract question prefix from eye button ID (e.g., "t3-q0" from "t3-q0-eye")
//    b. Find all input fields with IDs starting with question prefix + "-gap"
//    c. If found: treat as multi-gap question, fill all gaps with answers
//    d. If not found: treat as single-input question (Task 1, 2 format)
// 5. COMPATIBILITY: Works with all exercise types:
//    - Task 1, 2: Single input fields
//    - Task 3, 4: Multiple input fields per question
//    - Task 5: Option selection buttons
// 6. USER EXPERIENCE: Consistent behavior across all exercise types

// TASK 5 TYPE RECOGNITION AND HANDLING (CRITICAL UPDATE):
// 1. THERE ARE TWO DISTINCT TASK 5 FORMATS ACROSS DIFFERENT MODULES:
//    - MULTIPLE CHOICE (TYPE 1): Data has 'options' array property (Module 5a format)
//    - ERROR CORRECTION (TYPE 2): Data has 'words' array and 'errIdx' property (Module 4a format)
// 2. AUTOMATIC DETECTION ALGORITHM:
//    if (data[0].options && Array.isArray(data[0].options)) {
//        // MULTIPLE CHOICE - use renderPhrasalVerbs()
//    } else if (data[0].words && data[0].errIdx !== undefined) {
//        // ERROR CORRECTION - use renderErrorCorrection()
//    }
// 3. MULTIPLE CHOICE FEATURES:
//    - 3 option buttons per question
//    - Check All only validates selected questions
//    - Reset clears inline styles completely (style.cssText = '')
// 4. ERROR CORRECTION FEATURES:
//    - Clickable phrases with yellow highlight on selection
//    - Auto-fill input with selected phrase
//    - Show All auto-selects error phrase and shows correction
// 5. BOTH TYPES use Task 5 numbering but have completely different UI/UX patterns

// ALL TECHNICAL REQUIREMENTS from the original template are preserved
</script>
</body>
</html>
